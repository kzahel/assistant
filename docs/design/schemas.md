# Schema Reference

All schemas are defined in TypeScript using Zod as the source of truth. Config files are YAML (human-edited), logs are JSONL (append-only), state checkpoints are JSON (read-write).

## Skill Frontmatter

Skills use the [SKILL.md specification](https://agentskills.io/specification). The YAML frontmatter is the source for the generated skill index:

```typescript
// schemas/skill-frontmatter.ts
import { z } from "zod";

/** Extracted from SKILL.md YAML frontmatter */
export const SkillFrontmatterSchema = z.object({
  /** Kebab-case identifier, max 64 chars */
  name: z.string().max(64).regex(/^[a-z0-9-]+$/),
  /** Human-readable description, max 1024 chars */
  description: z.string().max(1024),
});
```

## Skill Index

Generated by the build step, embedded in `CLAUDE.md`. Provides compact discovery without loading full skill prompts.

```typescript
// schemas/skill-index.ts
import { z } from "zod";

export const SkillIndexEntrySchema = z.object({
  /** Skill name (from SKILL.md frontmatter) */
  name: z.string(),
  /** Short description (from SKILL.md frontmatter) */
  description: z.string(),
  /** Whether this skill has a config block in config.yaml */
  configured: z.boolean(),
  /** Absolute path to the skill directory */
  path: z.string(),
});

export const SkillIndexSchema = z.array(SkillIndexEntrySchema);
```

## Assistant Config

The root config for one assistant instance. Lives at `config.yaml` in the instance directory.

```typescript
// schemas/assistant.ts
import { z } from "zod";
import { ScheduleSchema } from "./schedule.ts";

export const AssistantConfigSchema = z.object({
  /** Human-readable name */
  name: z.string(),

  /** Path to soul.md relative to this config file */
  soul: z.string().default("./soul.md"),

  /** Where outputs go by default: session (new Claude session), push
      (web push via yepanywhere), signal, telegram, webhook, or log */
  defaultOutput: z.enum(["session", "push", "signal", "telegram", "webhook", "log"])
    .default("log"),

  /** Path to skills directory (default: ~/code/assistant/skills) */
  skillsDir: z.string().optional(),

  /** Per-skill configuration. Keys are skill directory names. */
  skills: z.record(z.string(), z.record(z.unknown())).optional(),

  /** Scheduled tasks */
  schedules: z.array(ScheduleSchema).default([]),
});
```

### Example (YAML)

```yaml
name: my-assistant
soul: ./soul.md
defaultOutput: push
skillsDir: ~/code/assistant/skills

skills:
  gmail:
    account: user@example.com
    folders: [INBOX]
    maxAge: 24h
  reddit:
    subreddits: [localllama, machinelearning, ycombinator]
    topN: 10
  signal:
    recipient: "+1234567890"
  browser:
    dataDir: ~/.browser-control

schedules:
  - name: morning-digest
    cron: "0 7 * * *"
    skills:
      - skill: gmail
      - skill: reddit
    output: push

  - name: pm-report
    cron: "0 17 * * 1-5"
    skills:
      - skill: daily-report
        args:
          include: [github-prs, deploys]
    output: session

  - name: weekend-reading
    cron: "0 9 * * 6"
    skills:
      - skill: reddit
        args:
          subreddits: [philosophy, historyporn]
          topN: 20
    output: log
```

## Schedule

A recurring task definition. Part of `AssistantConfigSchema.schedules`.

```typescript
// schemas/schedule.ts
import { z } from "zod";

export const SkillRefSchema = z.object({
  /** Skill directory name (must match a dir in skillsDir) */
  skill: z.string(),
  /** Override or extend the skill's config for this invocation */
  args: z.record(z.unknown()).optional(),
});

export const ScheduleStateSchema = z.object({
  lastRunAt: z.string().datetime().optional(),
  lastStatus: z.enum(["ok", "error", "skipped"]).optional(),
  lastSummary: z.string().optional(),
  consecutiveErrors: z.number().int().nonneg().default(0),
  maxConsecutiveErrors: z.number().int().positive().default(5),
});

export const ScheduleSchema = z.object({
  /** Unique name for this schedule */
  name: z.string(),

  /** Cron expression (standard 5-field: min hour dom mon dow) */
  cron: z.string(),

  /** Skills to run, in order */
  skills: z.array(SkillRefSchema).min(1),

  /** Where to send output (overrides assistant defaultOutput) */
  output: z.enum(["session", "push", "signal", "telegram", "webhook", "log"]).optional(),

  /** Disable without deleting */
  enabled: z.boolean().default(true),

  /** Runtime state (written by runner, not human-edited) */
  _state: ScheduleStateSchema.optional(),
});
```

### Schedule state

The `_state` field is written by the schedule runner after each execution. It lives inline in `config.yaml` under each schedule entry. This keeps the schedule definition and its runtime state co-located. A schedule auto-disables after `maxConsecutiveErrors` failures.

Example after a run:

```yaml
schedules:
  - name: morning-digest
    cron: "0 7 * * *"
    skills:
      - skill: gmail
      - skill: reddit
    _state:
      lastRunAt: "2026-02-20T07:00:08Z"
      lastStatus: ok
      lastSummary: "12 emails, 3 subreddits digested"
      consecutiveErrors: 0
```

## Activity Entry

A single line in `memory/activity-log.jsonl` or `logs/<date>.jsonl`.

```typescript
// schemas/activity.ts
import { z } from "zod";

export const ActivityEntrySchema = z.object({
  /** ISO 8601 timestamp */
  ts: z.string().datetime(),

  /** What triggered this run */
  trigger: z.enum(["schedule", "channel", "interactive", "self"]),

  /** Schedule name, channel name, or "interactive" */
  source: z.string(),

  /** Skill that ran */
  skill: z.string(),

  /** Outcome */
  status: z.enum(["ok", "error", "skipped"]),

  /** Wall-clock duration in milliseconds */
  durationMs: z.number().int().nonneg(),

  /** Human-readable summary of what happened */
  summary: z.string().optional(),

  /** Error message if status=error */
  error: z.string().optional(),
});
```

### Example (JSONL)

```jsonl
{"ts":"2026-02-20T07:00:03Z","trigger":"schedule","source":"morning-digest","skill":"gmail","status":"ok","durationMs":4200,"summary":"12 new emails, 3 flagged"}
{"ts":"2026-02-20T07:00:08Z","trigger":"schedule","source":"morning-digest","skill":"reddit","status":"ok","durationMs":8100,"summary":"Digested 3 subreddits, 30 posts"}
{"ts":"2026-02-20T12:34:00Z","trigger":"channel","source":"signal","skill":"reddit","status":"ok","durationMs":6300,"summary":"Answered question about r/localllama trends"}
{"ts":"2026-02-20T17:00:02Z","trigger":"schedule","source":"pm-report","skill":"daily-report","status":"error","durationMs":1200,"error":"GitHub API rate limited"}
```

## State Checkpoint

Per-skill cursor/checkpoint. Lives at `state/<skill>-<key>.json`.

```typescript
// schemas/state.ts
import { z } from "zod";

export const StateCheckpointSchema = z.object({
  /** Skill name */
  skill: z.string(),

  /** When this state was last written */
  updatedAt: z.string().datetime(),

  /** Skill-specific data (validated by the skill's own schema) */
  data: z.record(z.unknown()),
});
```

### Examples

```json
// state/gmail-last-seen.json
{
  "skill": "gmail",
  "updatedAt": "2026-02-20T07:00:03Z",
  "data": {
    "uidNext": 4582,
    "lastMessageId": "<abc123@mail.gmail.com>"
  }
}
```

```json
// state/reddit-last-run.json
{
  "skill": "reddit",
  "updatedAt": "2026-02-20T07:00:08Z",
  "data": {
    "lastScanned": "2026-02-20T07:00:08Z",
    "subredditCursors": {
      "localllama": "t3_abc123",
      "machinelearning": "t3_def456"
    }
  }
}
```

## Invocation Context

Passed via environment variables, read by `CLAUDE.md` prompt logic.

```typescript
// schemas/invocation.ts
import { z } from "zod";

export const ChannelContextSchema = z.object({
  /** Transport type */
  transport: z.enum(["signal", "telegram", "push", "webhook"]),
  /** Command to send a message back to the user */
  sendCommand: z.string(),
  /** Conversation thread ID */
  threadId: z.string().optional(),
});

export const InvocationContextSchema = z.object({
  /** How this session was triggered */
  trigger: z.enum(["cron", "interactive", "channel"]),
  /** Schedule name (when trigger=cron) */
  scheduleName: z.string().optional(),
  /** Who/what started this */
  source: z.string().optional(),
  /** Channel details (when trigger=channel) */
  channel: ChannelContextSchema.optional(),
});
```

### Environment variable encoding

```bash
# Interactive (default if unset)
ASSISTANT_TRIGGER=interactive

# Scheduled
ASSISTANT_TRIGGER=cron:morning-digest

# Channel
ASSISTANT_TRIGGER=channel:signal
ASSISTANT_CHANNEL='{"transport":"signal","sendCommand":"tsx lib/send.ts --to +1234567890","threadId":"conv-abc"}'
```

## Design Decisions

**YAML for config, JSONL for logs, JSON for state.** Each format matches its access pattern:
- Config is human-edited, read at startup → YAML (readable, commentable)
- Logs are append-only, read sequentially → JSONL (streamable, greppable)
- State is read-write by skills → JSON (simple parse/serialize)

**SKILL.md over custom format.** Using the Agent Skills standard means our skills work outside this format too — in Claude Code, Codex, Copilot, Goose, etc. No lock-in.

**Generated skill index over full inlining.** Vercel found that progressive disclosure (agent discovers skills on demand) fails 56% of the time. Full inlining wastes tokens. The generated index is the middle ground: always visible, compact (~50 tokens per skill), with a clear pointer to read the full SKILL.md when needed.

**`_state` inline in config.yaml.** Schedule runtime state lives alongside the schedule definition rather than in a separate file. The underscore prefix signals "managed by the system, not human-edited." This keeps related data co-located and avoids a proliferation of state files.

**`args` overlay `skills` config.** A schedule can override skill config per-invocation without duplicating the full config block. The runner merges `config.yaml → skills.<name>` with `schedule.skills[].args` at runtime.

**Skill config schemas are optional.** Skills can define a `config.schema.ts` for validation, but it's not required. Simple skills may not need structured config at all — just the `SKILL.md` prompt.
